[プログラムの説明]
　Graph:
　概要：有向重み付きグラフを扱うプログラムである。
　内容：後の作業に必要なグラフファイルを生成して、原本ファイルと比較する仕組みになっている。
　細部：既存のGraphと同じくファイルを読み込んでノードとエッジに分離するが、本コードではそれに加えて＠で表現されたエッジの重みが追加された。条件としてエッジの重みが負数でないことがある。

　Dijkstra:
　概要：与えられたグラフに対し、ダイクストラ法を利用して求めた親ノード木を求めるプログラムである。
　内容：親ノード木を求めるメソッドと2点間の最小経路を求めるメソッド2つを提供する。
　細部：
　doDijkstra(int start)：引数を始点としてダイクストラアルゴリズムを実行する。到達できない点に対しては-1を付与して、出力の際にxで表現する。基本的な構造は疑似コードに従った以下の過程で、利用される資料構造には、親ノードを表す配列pathTree, 始点からの距離を表す配列distance,　訪問したノードを記録するqueueなどがある。
　初期化：pathTreeを-1に、distanceを陽の無限に初期化して、全ノードを訪問していない状態にする。
　始点の処理：pathTree[start]を自身(start)に、distance[start]を０に設定する。
　以下の3つの過程は全ノードを訪問するまでループする。
　未訪問＆最小距離ノード確認：distance配列を巡回しながら訪問していない（queueにいない）ノードの中で、一番距離が短いノードを求める。
　ノードの訪問処理：上で求めたノードをqueueに入れることで訪問の処理を行う。
　エッジの経路更新可能の確認と処理：以後、そのノードに連結されているエッジを巡回しながら短い経路に交信できれば、distanceを更新して親ノードも更新する。

　getShortestPath(int start, int end)：始終点間の最小経路を求める。仕組みは終点から始点へ遡りながら探索する仕組みになっていて、本課題では始点を0に固定し、終点は0～6の結果を各々確認する。
 
　PQDijkjstra:
　概要：Dijkstraクラスを相続してより効率的に親ノード木を求めるプログラムである。
　内容：Dijkjstraで使った一般Queueの代わりに、PriorityQueueを利用して時間複雑度を減らした。
　細部：構造はDijkstraとほぼ同じである。但し、一般のqueueの代わりにPriorityQueueを利用するためデータ型及び比較条件を設定する必要がある。従って、必要な要素がnode, weightであることからEdgeクラスを相続したPQEdgeクラスを生成し、Comparableインターフェースを相続させる。この変化で既存の「未訪問＆最小距離ノード確認」段階がPriorityQueueの最初の要素を取ることになり、時間が短縮される効果が得られる。

[まとめ]
　本課題では前講義とは違って、有向重み付きグラフに対する最小費用経路探索に使われるダイクストラ法を練習した。エッジの重みが負数でない条件があるが、O(V^2)で問題が解決できる長所がある。本課題ではO(V^2)の基本アルゴリズムと、PriorityQueueを用いたO((E+V)logV)のアルゴリズム両方を具現した。基本アルゴリズムの中でループごとに全ノードを探索してO(V)で最小距離ノードを求める仕組みを、自動的に最小距離ノードが前方に位置されるPriorityQueueを用いてO(1)で改良した。但し、ノードを挿入する度に位置を2進探索で探すため、O(logV)の時間が掛かる。

[理解度]
　B
[感想]
　特にありません。
[特記事項]
　特にありません。